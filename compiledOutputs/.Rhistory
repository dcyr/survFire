ecozoneMap <- readShapeSpatial(shapeFile, proj4string = CRS("+proj=longlat +datum=WGS84"))
## renaming and reordering factors
levels(ecozoneMap$ZONE_NAME)[which(levels(ecozoneMap$ZONE_NAME)=="Boreal PLain")] <- "Boreal Plain"
ecozoneMap$ZONE_NAME <- factor(ecozoneMap$ZONE_NAME, levels=c("MixedWood Plain",
"Atlantic Maritime",
"Boreal Shield",
"Prairie",
"Boreal Plain",
"Montane Cordillera",
"Pacific Maritime",
"Boreal Cordillera",
"Taiga Shield",
"Taiga Plain",
"Taiga Cordillera",
"Hudson Plain",
"Southern Arctic",
"Northern Arctic",
"Arctic Cordillera"))
###  specifying colors
cols <- c("palegreen",
"seagreen3",
"palegreen4",
"navajowhite1",
"darkseagreen2",
"darkkhaki",
"darkolivegreen4",
"burlywood4",
"bisque3",
"burlywood3",
"darkslategray4",
"lemonchiffon4",
"lightblue1",
"lightcyan1",
"lightblue3")
names(cols) <- levels(ecozoneMap$ZONE_NAME)
can1 <- getData('GADM', country="CAN", level=1) ## level 1: provinces
crsArea <- CRS("+init=epsg:3153") ### NAD83(CSRS) / BC AlbersAlbers Equal Area
# projecting maps
can1<- spTransform(can1, crsArea)# NAD83(CSRS) / Statistics Canada Lambert
ecozoneMap <- spTransform(ecozoneMap, crsArea)
simArea <- projectRaster(simArea, crs = crsArea)
can1
ecozoneMap
simArea
r <- ecoRaster
r <- setExtent(r, ext=e, keepres=TRUE, snap=TRUE)
r[] <- NA
plot(r, box=FALSE, axes=F, frame.plot=F, xaxt='n', yaxt='n', main= paste0("Simulated quadrat - ", ecozones[which(ecozones$code == a), "name"]))
### ecozone plot
plot(ecoRaster, breaks=breakpoints,  col=x$cols, legend=FALSE, add=TRUE)
### Provinces boundaries
plot(can1Cropped, border="grey25", lwd=1, add=TRUE)
### simulation areas
plot(simArea, add=TRUE, col="black", legend=FALSE)
simArea
ecoRaster
levels(ecoRaster)
plot(ecoRaster)
x$ID <- 1:nrow(x)
levels(ecoRaster) <- x
x <- levels(ecoRaster)[[1]]
x$ecoName <- levels(ecozoneMap$ZONE_NAME)[x$ID]
x$cols <- as.character(cols)[x$ID]
x$ID <- 1:nrow(x)
x
levels(ecoRaster) <- x
plot(ecoRaster)
values(ecoRaster)
plot(ecoRaster, breaks=breakpoints,  col=x$cols, legend=FALSE, add=TRUE)
plot(r, box=FALSE, axes=F, frame.plot=F, xaxt='n', yaxt='n', main= paste0("Simulated quadrat - ", ecozones[which(ecozones$code == a), "name"]))
breakpoints
unique(values(ecoRaster))
x <- levels(ecoRaster)[[1]]
x$ecoName <- levels(ecozoneMap$ZONE_NAME)[x$ID]
x$cols <- as.character(cols)[x$ID]
x$ID <- 1:nrow(x)
levels(ecoRaster) <- x
breakpoints <- unique(values(ecoRaster))
breakpoints
breakpoints <- breakpoints[-(is.na(breakpoints))]
breakpoints <- breakpoints[order(breakpoints)]
breakpoints <- c(min(breakpoints)-1, breakpoints)
breakpoints
breakpoints <- breakpoints[-(is.na(breakpoints))]
breakpoints
breakpoints <- unique(values(ecoRaster))
breakpoints
breakpoints <- breakpoints[is.na(breakpoints)==F]
breakpoints
breakpoints <- breakpoints[order(breakpoints)]
breakpoints
breakpoints <- c(min(breakpoints)-1, breakpoints)
breakpoints
r <- ecoRaster
r <- setExtent(r, ext=e, keepres=TRUE, snap=TRUE)
r[] <- NA
plot(r, box=FALSE, axes=F, frame.plot=F, xaxt='n', yaxt='n', main= paste0("Simulated quadrat - ", ecozones[which(ecozones$code == a), "name"]))
### ecozone plot
plot(ecoRaster, breaks=breakpoints,  col=x$cols, legend=FALSE, add=TRUE)
x
ecoRaster <- ratify(ecoRaster)
x <- levels(ecoRaster)[[1]]
x$ecoName <- levels(ecozoneMap$ZONE_NAME)[x$ID]
x$cols <- as.character(cols)[x$ID]
x$ID <- 1:nrow(x)
levels(ecoRaster) <- x
ecoRaster <- ratify(ecoRaster)
ecoRaster <- ratify(ecoRaster)
x <- levels(ecoRaster)[[1]]
x$ecoName <- levels(ecozoneMap$ZONE_NAME)[x$ID]
x$cols <- as.character(cols)[x$ID]
x
breakpoints <- unique(values(ecoRaster))
breakpoints <- breakpoints[is.na(breakpoints)==F]
breakpoints <- breakpoints[order(breakpoints)]
breakpoints <- c(min(breakpoints)-1, breakpoints)
r <- ecoRaster
r <- setExtent(r, ext=e, keepres=TRUE, snap=TRUE)
r[] <- NA
plot(r, box=FALSE, axes=F, frame.plot=F, xaxt='n', yaxt='n', main= paste0("Simulated quadrat - ", ecozones[which(ecozones$code == a), "name"]))
### ecozone plot
plot(ecoRaster, breaks=breakpoints,  col=x$cols, legend=FALSE, add=TRUE)
### Provinces boundaries
plot(can1Cropped, border="grey25", lwd=1, add=TRUE)
```{r mapPlot, echo=FALSE, cache=TRUE, fig.height=5, fig.width=7, fig.align="center"}
rm(list=ls())
inputDir <- "./data"
x <- list.files(inputDir)
x
inputDir
read.csv("/home/dcyr/Desktop/speciesTraitsParams.csv")
speciesTraits <- read.csv("/home/dcyr/Desktop/speciesTraitsParams.csv")
vegCodes <- read.csv("/home/dcyr/Dropbox/LANDIS-II_IA_SCF/vegCodes.csv")
vegCodes
?merge
merge(speciesTraits, vegCodes, by.y = "LandisCode")
vegCodes
View(vegCodes)
View(speciesTraits)
merge(speciesTraits, vegCodes)
merge(speciesTraits, vegCodes)[,c(1:16, 25:34)]
merge(speciesTraits, vegCodes)[,c(1:16, 26:34)]
foo <- merge(speciesTraits, vegCodes)[,c(1:16, 26:34)]
foo <- merge(speciesTraits, vegCodes)[,c(1:16, 26:34)]
stack(foo[,26:34])
stack(foo[,17:25])
stackFoo <- stack(foo[,1-17:25])
stackFoo <- stack(foo[,c(1,17:25)])
require(reshape)
2
require(reshape2)
?melt
View(foo)
colnames(foo)
areas <- colnames(foo)[16:25]
areas
areas <- colnames(foo)[17:25]
areas
melt(foo, id.vars = "LandisCode")
melt(foo[c(1, 17:25)], id.vars = "LandisCode")
fo02 <- melt(foo[c(1, 17:25)], id.vars = "LandisCode")
foo2 <- melt(foo[c(1, 17:25)], id.vars = "LandisCode")
foo2[foo2$value==TRUE]
foo2[foo2$value==TRUE,]
foo2[foo2$value==TRUE,1:2]
foo2 <- foo2[foo2$value==TRUE,1:2]
merge(foo2, foo)
foo <- merge(foo2, foo)
foo
foo[,-areas]
ncol(foo)
foo[,-(areas)]
foo[,-(18:26)]
foo <- foo[,-(18:26)]
speciesTraits <- read.csv("/home/dcyr/Desktop/speciesTraitsParams.csv")
vegCodes <- read.csv("/home/dcyr/Dropbox/LANDIS-II_IA_SCF/vegCodes.csv")
foo <- merge(speciesTraits, vegCodes)[,c(1:16, 26:34)]
require(reshape2)
stackFoo <- melt(foo, id.vars = c)
areas <- colnames(foo)[17:25]
areas <- colnames(foo)[17:25]
speciesTraits <- read.csv("/home/dcyr/Desktop/speciesTraitsParams.csv")
vegCodes <- read.csv("/home/dcyr/Dropbox/LANDIS-II_IA_SCF/vegCodes.csv")
foo <- merge(speciesTraits, vegCodes)[,c(1:16, 26:34)]
require(reshape2)
areas <- colnames(foo)[17:25]
foo2 <- melt(foo[c(1, 17:25)], id.vars = "LandisCode")
foo2 <- foo2[foo2$value==TRUE,1:2]
foo <- merge(foo2, foo)
foo <- foo[,-(18:26)]
View(foo)
require(dplyr)
colnames(foo)[2] <- "area"
foo
colnames(foo)[2] <- "Area"
foo <- foo %>% arrange(LandisCode, Area)
foo
write.csv(foo, file = "speciesTraits.csv")
getwd()
write.csv(foo, file = "speciesTraits.csv", row.names = F)
sampl <- list()
opts_chunk$set(dev = 'pdf')
hist(means, main = "Distribution of sample means", breaks = 15, freq = F,
cex = 0.5, xlab="Mean")
hist(sampl)
sampl <- rexp(n, lambda)
lambda <- 0.2 ## rate parameter of the exponential
nSims <- 1000 ## number of samples / simulations
n <- 40 ## sample size
means <- variances <- NULL
for (i in 1: nSims) {
sampl <- rexp(n, lambda)
means <- c(means, mean(sampl))
variances <-  c(variances, var(sampl))
}
### example of how the values of one simulations are distributed
hist(sampl)
nbrhood <- matrix(c(-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1), nrow=2)
nbrhood
n.rows <- dim(x)[1]
n.cols <- dim(x)[2]
matrix(0, nrow = 100, ncol = 100)
tsf <- matrix(0, nrow = 100, ncol = 100)
x <- tsf
n.rows <- dim(x)[1]
n.rows
nCols <- dim(x)[2]
nCols
nbrhood <- matrix(c(-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1), nrow=2)
<=
x[start] != 1
start <- 500
nsize <- 1000
x <- tsf
x[start]
x[start] != 1
nRows <- dim(x)[1]
nCols <- dim(x)[2]
nCols
nbrhood <- matrix(c(-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1), nrow=2)
state <- tsf
nSize
nSize <- 500
state
i <- 1
nSize
indices <- c(NA, nSize)
indices
i <- 1
fireSpread <- function(x, nSize, start) {
if (x[start] != 1) stop("Attempting to begin on an burned cell")
nRows <- dim(x)[1]
nCols <- dim(x)[2]
nbrhood <- matrix(c(-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1), nrow=2)
#
# Adjoin one more random cell and update `state`, which records
# (1) the unburned cells and (2) already burned cells.
#
spread <- function(state) {
#
# Find all unburned neighbors that lie within the extent of `x` and
# are unburned.
#
neighbors <- function(i) {
n <- c((i-1) %% n.rows+1, floor((i - 1) / n.rows+1)) + nbrhood
n <- n[, n[1,] >= 1 & n[2,] >= 1 & n[1,] <= n.rows & n[2,] <= n.cols,
drop=FALSE]             # Remain inside the extent of `x`.
n <- n[1,] + (n[2,]-1)*n.rows  # Convert to *vector* indexes into `x`.
n <- n[x[n] == 1]                # Stick to valid cells in `x`.
n <- setdiff(n, state$burned)# Remove any burned cells.
return (n)
}
#
# Select one unburned cell uniformly at random.
# Return an updated state.
#
j <- ceiling(runif(1) * length(state$unburned))
i <- state$unburned[j]
return(list(index=i,
unburned = union(state$unburned[-j], neighbors(i)),
burned = c(state$burned, i)))
}
#
# Initialize the state.
# (If `start` is missing, choose a value at random.)
#
if(missing(start)) {
indexes <- 1:(n.rows * n.cols)
indexes <- indexes[x[indexes]==1]
start <- sample(indexes, 1)
}
if(length(start)==2) start <- start[1] + (start[2]-1)*n.rows
state <- list(unburned=start, burned=c())
#
# Grow for as long as possible and as long as needed.
#
i <- 1
indices <- c(NA, nSize)
while(length(state$unburned) > 0 && i <= nSize) {
state <- spread(state)
indices[i] <- state$index
i <- i+1
}
#
# Return a grid of generation numbers from 1, 2, ... through nSize.
#
indices <- indices[!is.na(indices)]
y <- matrix(NA, n.rows, n.cols)
y[indices] <- 1:length(indices)
return(y)
}
rm(list=ls())
####################################################################
####################################################################
setwd("/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp")
outputFolder <- paste(getwd(), "outputs", sep="/")
wwd <- paste(getwd(), Sys.Date(), sep="/")
dir.create(wwd)
setwd(wwd)
rm(wwd)
####################################################################
####################################################################
######
######      compiling simulation outputs
######      +
######      simulated sampling
# source("../scripts/censFnc.R")
# samplingEffort <- c(10, 20, 30, 50, 75, 94, 250)
# resamplingN <- 10000
# binWidth <- c(5, 25, 50, 75, 100, 125, 150, 175, 200, 250, 300)
# censMin <- 100
# censMax <- 300
####################################################################
####################################################################
x <- list.files(outputFolder)
simInfo <- gsub(".RData", "", x)
simInfo <- strsplit(simInfo, "_")
fc <- as.numeric(lapply(simInfo, function(x) x[2]))
corr <- as.numeric(lapply(simInfo, function(x) x[3]))
require(doSNOW)
clusterN <- 3  ### choose number of nodes to add to cluster.
cl = makeCluster(clusterN)
registerDoSNOW(cl)
tsfFinalList <- foreach(i = seq_along(x)) %dopar%  {#
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[length(tsfStack)]]))
rm(tsfStack)
}
return(tsfFinal)
#print(paste(i, "of", length(x)))
}
rm(list=ls())
stopCluster(cl)
i <- 1
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[length(tsfStack)]]))
rm(tsfStack)
}
####################################################################
####################################################################
####################################################################
rm(list=ls())
####################################################################
####################################################################
setwd("/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp")
outputFolder <- paste(getwd(), "outputs", sep="/")
wwd <- paste(getwd(), Sys.Date(), sep="/")
dir.create(wwd)
setwd(wwd)
rm(wwd)
####################################################################
####################################################################
######
######      compiling simulation outputs
######      +
######      simulated sampling
# source("../scripts/censFnc.R")
# samplingEffort <- c(10, 20, 30, 50, 75, 94, 250)
# resamplingN <- 10000
# binWidth <- c(5, 25, 50, 75, 100, 125, 150, 175, 200, 250, 300)
# censMin <- 100
# censMax <- 300
####################################################################
####################################################################
x <- list.files(outputFolder)
simInfo <- gsub(".RData", "", x)
simInfo <- strsplit(simInfo, "_")
fc <- as.numeric(lapply(simInfo, function(x) x[2]))
corr <- as.numeric(lapply(simInfo, function(x) x[3]))
require(doSNOW)
clusterN <- 3  ### choose number of nodes to add to cluster.
cl = makeCluster(clusterN)
registerDoSNOW(cl)
i <- 1
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[length(tsfStack)]]))
rm(tsfStack)
}
r
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
seq_along(output)
r
tsfStack <- output[[r]][["tsf"]]
tsfStack
tsfFinal <- cbind(tsfFinal, values(tsfStack[[length(tsfStack)]]))
values(tsfStack[[length(tsfStack)]])
length(tsfStack)
tsfStack <- output[[r]][["tsf"]]
tsfStack
length(tsfStack)
tsfStack
nlayers(tsfStack)
tsfFinal <- cbind(tsfFinal, values(tsfStack[[nlayers(tsfStack)]]))
tsfFinal
stopCluster(cl)
cl = makeCluster(clusterN)
registerDoSNOW(cl)
tsfFinalList <- foreach(i = seq_along(x)) %dopar%  {#
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[nlayers(tsfStack)]]))
rm(tsfStack)
}
return(tsfFinal)
#print(paste(i, "of", length(x)))
}
names(tsfFinalList)
tsfFinalList
length(tsfFinalList)
gsub(".RData", "", x)
gsub("simOutput_|.RData", "", x)
length(tsfFinalList) <- paste0("tsfFinal_", gsub("simOutput_|.RData", "", x))
paste0("tsfFinal_", gsub("simOutput_|.RData", "", x))
names(tsfFinalList) <- paste0("tsfFinal_", gsub("simOutput_|.RData", "", x))
names(tsfFinalList)
save(tsfFinalList, file = "tsfFinal.RData")
rm(list=ls())
source('/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp/postProcessing.R', echo=TRUE)
output <- do.call("rbind", outputList)
save(output, file = "simOutputCompiled.RData")
load("/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp/2016-01-15/simOutputCompiled.RData")
rm(list=ls())
load("/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp/2016-01-15/simOutputCompiled.RData")
summary(output)
nrow(output)
## simulated sampling
###########################################
cl = makeCluster(clusterN)
registerDoSNOW(cl)
tsfFinalList <- foreach(i = seq_along(x)) %dopar%  {#
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[nlayers(tsfStack)]]))
rm(tsfStack)
}
return(tsfFinal)
#print(paste(i, "of", length(x)))
}
stopCluster(cl)
names(tsfFinalList) <- paste0(gsub("simOutput_|.RData", "", x))
save(tsfFinalList, file = "tsfFinal.RData")
cl = makeCluster(clusterN)
clusterN <- 2  ### choose number of nodes to add to cluster.
cl = makeCluster(clusterN)
registerDoSNOW(cl)
tsfFinalList <- foreach(i = seq_along(x)) %dopar%  {#
require(raster)
##
output <- get(load(paste(outputFolder, x[i], sep="/")))
tsfFinal <- NULL
##
for (r in seq_along(output)) {
tsfStack <- output[[r]][["tsf"]]
tsfFinal <- cbind(tsfFinal, values(tsfStack[[nlayers(tsfStack)]]))
rm(tsfStack)
}
return(tsfFinal)
#print(paste(i, "of", length(x)))
}
stopCluster(cl)
names(tsfFinalList) <- paste0(gsub("simOutput_|.RData", "", x))
save(tsfFinalList, file = "tsfFinal.RData")
source('/media/dcyr/Windows7_OS/Travail/SCF/fcEstimationExp/postProcessing.R', echo=TRUE)
